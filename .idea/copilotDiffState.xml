<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/content/content.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/content/content.js" />
              <option name="originalContent" value="// Content script for enhanced page interaction&#10;class SnapDocContent {&#10;  constructor() {&#10;    this.init();&#10;  }&#10;&#10;  init() {&#10;    this.createOverlay();&#10;    this.setupEventListeners();&#10;    this.injectStyles();&#10;  }&#10;&#10;  createOverlay() {&#10;    // Create screenshot overlay for visual feedback&#10;    this.overlay = document.createElement('div');&#10;    this.overlay.id = 'snap-doc-overlay';&#10;    this.overlay.style.cssText = `&#10;      position: fixed;&#10;      top: 0;&#10;      left: 0;&#10;      width: 100%;&#10;      height: 100%;&#10;      background: rgba(0, 0, 0, 0.1);&#10;      z-index: 999999;&#10;      pointer-events: none;&#10;      opacity: 0;&#10;      transition: opacity 0.2s ease;&#10;      display: none;&#10;    `;&#10;    document.body.appendChild(this.overlay);&#10;&#10;    // Create capture indicator&#10;    this.indicator = document.createElement('div');&#10;    this.indicator.id = 'snap-doc-indicator';&#10;    this.indicator.style.cssText = `&#10;      position: fixed;&#10;      top: 20px;&#10;      right: 20px;&#10;      background: #4CAF50;&#10;      color: white;&#10;      padding: 10px 15px;&#10;      border-radius: 5px;&#10;      font-family: system-ui, sans-serif;&#10;      font-size: 14px;&#10;      z-index: 1000000;&#10;      box-shadow: 0 2px 10px rgba(0,0,0,0.3);&#10;      transform: translateY(-100px);&#10;      transition: transform 0.3s ease;&#10;      display: none;&#10;    `;&#10;    this.indicator.textContent = ' Screenshot captured!';&#10;    document.body.appendChild(this.indicator);&#10;  }&#10;&#10;  setupEventListeners() {&#10;    // Listen for messages from background script&#10;    chrome.runtime.onMessage.addListener((msg, sender, sendResponse) =&gt; {&#10;      switch (msg.type) {&#10;        case 'SHOW_CAPTURE_FEEDBACK':&#10;          this.showCaptureFeedback();&#10;          break;&#10;        case 'HIGHLIGHT_ELEMENT':&#10;          this.highlightElement(msg.selector);&#10;          break;&#10;        case 'GET_ELEMENT_INFO':&#10;          sendResponse(this.getElementInfo(msg.selector));&#10;          break;&#10;      }&#10;    });&#10;&#10;    // Keyboard shortcuts&#10;    document.addEventListener('keydown', (e) =&gt; {&#10;      // Ctrl/Cmd + Shift + S for quick capture&#10;      if ((e.ctrlKey || e.metaKey) &amp;&amp; e.shiftKey &amp;&amp; e.key === 'S') {&#10;        e.preventDefault();&#10;        this.quickCapture();&#10;      }&#10;    });&#10;  }&#10;&#10;  injectStyles() {&#10;    const style = document.createElement('style');&#10;    style.textContent = `&#10;      .snap-doc-highlight {&#10;        outline: 3px solid #ff4444 !important;&#10;        outline-offset: 2px !important;&#10;        background-color: rgba(255, 68, 68, 0.1) !important;&#10;      }&#10;      &#10;      .snap-doc-flash {&#10;        animation: snap-doc-flash 0.3s ease-out;&#10;      }&#10;      &#10;      @keyframes snap-doc-flash {&#10;        0% { background-color: rgba(255, 255, 255, 0.8); }&#10;        100% { background-color: transparent; }&#10;      }&#10;    `;&#10;    document.head.appendChild(style);&#10;  }&#10;&#10;  async quickCapture() {&#10;    this.showCaptureFeedback();&#10;&#10;    try {&#10;      // Send capture request to background&#10;      const result = await chrome.runtime.sendMessage({&#10;        type: 'CAPTURE_SCREENSHOT',&#10;        options: { source: 'keyboard-shortcut' }&#10;      });&#10;&#10;      if (result.error) {&#10;        throw new Error(result.error);&#10;      }&#10;&#10;      this.showSuccessIndicator();&#10;    } catch (error) {&#10;      console.error('Quick capture failed:', error);&#10;      this.showErrorIndicator();&#10;    }&#10;  }&#10;&#10;  showCaptureFeedback() {&#10;    // Flash effect on the page&#10;    document.body.classList.add('snap-doc-flash');&#10;    setTimeout(() =&gt; {&#10;      document.body.classList.remove('snap-doc-flash');&#10;    }, 300);&#10;&#10;    // Show overlay briefly&#10;    this.overlay.style.display = 'block';&#10;    this.overlay.style.opacity = '1';&#10;    setTimeout(() =&gt; {&#10;      this.overlay.style.opacity = '0';&#10;      setTimeout(() =&gt; {&#10;        this.overlay.style.display = 'none';&#10;      }, 200);&#10;    }, 100);&#10;  }&#10;&#10;  showSuccessIndicator() {&#10;    this.indicator.style.background = '#4CAF50';&#10;    this.indicator.textContent = ' Screenshot captured!';&#10;    this.showIndicator();&#10;  }&#10;&#10;  showErrorIndicator() {&#10;    this.indicator.style.background = '#f44336';&#10;    this.indicator.textContent = '❌ Capture failed!';&#10;    this.showIndicator();&#10;  }&#10;&#10;  showIndicator() {&#10;    this.indicator.style.display = 'block';&#10;    setTimeout(() =&gt; {&#10;      this.indicator.style.transform = 'translateY(0)';&#10;    }, 10);&#10;&#10;    setTimeout(() =&gt; {&#10;      this.indicator.style.transform = 'translateY(-100px)';&#10;      setTimeout(() =&gt; {&#10;        this.indicator.style.display = 'none';&#10;      }, 300);&#10;    }, 2000);&#10;  }&#10;&#10;  highlightElement(selector) {&#10;    // Remove existing highlights&#10;    document.querySelectorAll('.snap-doc-highlight').forEach(el =&gt; {&#10;      el.classList.remove('snap-doc-highlight');&#10;    });&#10;&#10;    // Add highlight to new element&#10;    const element = document.querySelector(selector);&#10;    if (element) {&#10;      element.classList.add('snap-doc-highlight');&#10;      element.scrollIntoView({ behavior: 'smooth', block: 'center' });&#10;    }&#10;  }&#10;&#10;  getElementInfo(selector) {&#10;    const element = document.querySelector(selector);&#10;    if (!element) return null;&#10;&#10;    const rect = element.getBoundingClientRect();&#10;    return {&#10;      tagName: element.tagName,&#10;      className: element.className,&#10;      id: element.id,&#10;      text: element.textContent?.slice(0, 100),&#10;      rect: {&#10;        x: rect.x,&#10;        y: rect.y,&#10;        width: rect.width,&#10;        height: rect.height&#10;      }&#10;    };&#10;  }&#10;&#10;  // Get page metadata for better documentation&#10;  getPageMetadata() {&#10;    return {&#10;      title: document.title,&#10;      url: window.location.href,&#10;      description: document.querySelector('meta[name=&quot;description&quot;]')?.content || '',&#10;      keywords: document.querySelector('meta[name=&quot;keywords&quot;]')?.content || '',&#10;      author: document.querySelector('meta[name=&quot;author&quot;]')?.content || '',&#10;      viewport: {&#10;        width: window.innerWidth,&#10;        height: window.innerHeight&#10;      },&#10;      scroll: {&#10;        x: window.scrollX,&#10;        y: window.scrollY&#10;      },&#10;      timestamp: new Date().toISOString()&#10;    };&#10;  }&#10;}&#10;&#10;// Initialize content script&#10;if (document.readyState === 'loading') {&#10;  document.addEventListener('DOMContentLoaded', () =&gt; new SnapDocContent());&#10;} else {&#10;  new SnapDocContent();&#10;}&#10;" />
              <option name="updatedContent" value="// No content script needed for original Snap Doc extension" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/popup/popup.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/popup/popup.css" />
              <option name="originalContent" value="body {&#10;  font-family: system-ui, sans-serif;&#10;  width: 320px;&#10;  margin: 0;&#10;  padding: 1rem;&#10;}&#10;&#10;h1 {&#10;  font-size: 1.2rem;&#10;  margin-top: 0;&#10;}&#10;&#10;.controls {&#10;  display: flex;&#10;  gap: 0.5rem;&#10;  align-items: center;&#10;  margin-bottom: 1rem;&#10;}&#10;&#10;.controls button {&#10;  flex: 1;&#10;  margin-top: 0;&#10;}&#10;&#10;#counter {&#10;  font-size: 0.85rem;&#10;  color: #666;&#10;  white-space: nowrap;&#10;}&#10;&#10;button {&#10;  appearance: none;&#10;  padding: 0.5rem 0.75rem;&#10;  margin-top: 0.5rem;&#10;  border: 1px solid #888;&#10;  border-radius: 0.5rem;&#10;  background: #f5f5f5;&#10;  cursor: pointer;&#10;  width: 100%;&#10;}&#10;&#10;button:hover {&#10;  background: #e5e5e5;&#10;}&#10;&#10;button:disabled {&#10;  opacity: 0.5;&#10;  cursor: not-allowed;&#10;}&#10;&#10;#thumbs {&#10;  display: flex;&#10;  flex-wrap: wrap;&#10;  gap: 0.25rem;&#10;  margin: 0.5rem 0;&#10;  max-height: 200px;&#10;  overflow-y: auto;&#10;}&#10;&#10;#thumbs img {&#10;  width: 48px;&#10;  height: 48px;&#10;  object-fit: cover;&#10;  border: 1px solid #ccc;&#10;  border-radius: 0.25rem;&#10;}&#10;&#10;.thumb-item {&#10;  display: flex;&#10;  gap: 0.5rem;&#10;  align-items: flex-start;&#10;  padding: 0.5rem;&#10;  border: 1px solid #eee;&#10;  border-radius: 0.25rem;&#10;  background: #fafafa;&#10;}&#10;&#10;.thumb-item img {&#10;  width: 60px;&#10;  height: 40px;&#10;  object-fit: cover;&#10;  border: 1px solid #ccc;&#10;  border-radius: 0.25rem;&#10;  flex-shrink: 0;&#10;}&#10;&#10;.thumb-content {&#10;  flex: 1;&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 0.25rem;&#10;}&#10;&#10;.thumb-title {&#10;  font-size: 0.85rem;&#10;  font-weight: bold;&#10;  color: #333;&#10;}&#10;&#10;.thumb-annotation {&#10;  width: 100%;&#10;  padding: 0.25rem;&#10;  border: 1px solid #ddd;&#10;  border-radius: 0.25rem;&#10;  font-size: 0.8rem;&#10;  resize: none;&#10;  height: 40px;&#10;}&#10;&#10;.thumb-controls {&#10;  display: flex;&#10;  gap: 0.25rem;&#10;}&#10;&#10;.thumb-btn {&#10;  padding: 0.25rem 0.5rem;&#10;  font-size: 0.7rem;&#10;  margin: 0;&#10;  width: auto;&#10;  min-width: 50px;&#10;}&#10;&#10;.thumb-btn.delete {&#10;  background: #ffebee;&#10;  border-color: #e57373;&#10;  color: #c62828;&#10;}&#10;&#10;.thumb-btn.delete:hover {&#10;  background: #ffcdd2;&#10;}&#10;&#10;.thumb-btn.move {&#10;  background: #e3f2fd;&#10;  border-color: #64b5f6;&#10;  color: #1976d2;&#10;}&#10;&#10;.thumb-btn.move:hover {&#10;  background: #bbdefb;&#10;}&#10;&#10;.export-section {&#10;  margin-top: 1rem;&#10;  padding-top: 1rem;&#10;  border-top: 1px solid #ddd;&#10;}&#10;&#10;.export-settings {&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 0.5rem;&#10;  margin-bottom: 1rem;&#10;}&#10;&#10;.export-settings label {&#10;  font-size: 0.85rem;&#10;  font-weight: bold;&#10;  color: #333;&#10;}&#10;&#10;.export-settings input,&#10;.export-settings select {&#10;  padding: 0.5rem;&#10;  border: 1px solid #ddd;&#10;  border-radius: 0.25rem;&#10;  font-size: 0.9rem;&#10;}&#10;&#10;.empty-state {&#10;  text-align: center;&#10;  color: #666;&#10;  font-style: italic;&#10;  padding: 2rem;&#10;}&#10;&#10;/* Sortable styles */&#10;.thumb-item.sortable-ghost {&#10;  opacity: 0.4;&#10;}&#10;&#10;.thumb-item.sortable-chosen {&#10;  background: #e3f2fd;&#10;}&#10;" />
              <option name="updatedContent" value="body {&#10;  font-family: system-ui, sans-serif;&#10;  width: 350px;&#10;  margin: 0;&#10;  padding: 1rem;&#10;}&#10;&#10;h1 {&#10;  font-size: 1.2rem;&#10;  margin-top: 0;&#10;  text-align: center;&#10;}&#10;&#10;.controls {&#10;  display: flex;&#10;  gap: 0.5rem;&#10;  align-items: center;&#10;  margin-bottom: 1rem;&#10;}&#10;&#10;.controls button {&#10;  flex: 1;&#10;  margin-top: 0;&#10;}&#10;&#10;#counter {&#10;  font-size: 0.85rem;&#10;  color: #666;&#10;  white-space: nowrap;&#10;}&#10;&#10;button {&#10;  appearance: none;&#10;  padding: 0.5rem 0.75rem;&#10;  margin-top: 0.5rem;&#10;  border: 1px solid #888;&#10;  border-radius: 0.5rem;&#10;  background: #f5f5f5;&#10;  cursor: pointer;&#10;  width: 100%;&#10;  font-size: 0.9rem;&#10;}&#10;&#10;button:hover {&#10;  background: #e5e5e5;&#10;}&#10;&#10;button:disabled {&#10;  opacity: 0.5;&#10;  cursor: not-allowed;&#10;}&#10;&#10;#thumbs {&#10;  display: flex;&#10;  flex-wrap: wrap;&#10;  gap: 0.25rem;&#10;  margin: 0.5rem 0;&#10;  max-height: 200px;&#10;  overflow-y: auto;&#10;  border: 1px solid #ddd;&#10;  border-radius: 0.5rem;&#10;  padding: 0.5rem;&#10;}&#10;&#10;#thumbs img {&#10;  width: 48px;&#10;  height: 48px;&#10;  object-fit: cover;&#10;  border: 1px solid #ccc;&#10;  border-radius: 0.25rem;&#10;}&#10;&#10;.thumb-item {&#10;  display: flex;&#10;  gap: 0.5rem;&#10;  align-items: flex-start;&#10;  padding: 0.5rem;&#10;  border: 1px solid #eee;&#10;  border-radius: 0.25rem;&#10;  background: #fafafa;&#10;}&#10;&#10;.thumb-item img {&#10;  width: 60px;&#10;  height: 40px;&#10;  object-fit: cover;&#10;  border: 1px solid #ccc;&#10;  border-radius: 0.25rem;&#10;  flex-shrink: 0;&#10;}&#10;&#10;.thumb-content {&#10;  flex: 1;&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 0.25rem;&#10;}&#10;&#10;.thumb-title {&#10;  font-size: 0.85rem;&#10;  font-weight: bold;&#10;  color: #333;&#10;}&#10;&#10;.thumb-annotation {&#10;  width: 100%;&#10;  padding: 0.25rem;&#10;  border: 1px solid #ddd;&#10;  border-radius: 0.25rem;&#10;  font-size: 0.8rem;&#10;  resize: none;&#10;  height: 40px;&#10;}&#10;&#10;.thumb-controls {&#10;  display: flex;&#10;  gap: 0.25rem;&#10;}&#10;&#10;.thumb-btn {&#10;  padding: 0.25rem 0.5rem;&#10;  font-size: 0.7rem;&#10;  margin: 0;&#10;  width: auto;&#10;  min-width: 50px;&#10;}&#10;&#10;.thumb-btn.delete {&#10;  background: #ffebee;&#10;  border-color: #e57373;&#10;  color: #c62828;&#10;}&#10;&#10;.thumb-btn.delete:hover {&#10;  background: #ffcdd2;&#10;}&#10;&#10;.thumb-btn.move {&#10;  background: #e3f2fd;&#10;  border-color: #64b5f6;&#10;  color: #1976d2;&#10;}&#10;&#10;.thumb-btn.move:hover {&#10;  background: #bbdefb;&#10;}&#10;&#10;.export-section {&#10;  margin-top: 1rem;&#10;  padding-top: 1rem;&#10;  border-top: 1px solid #ddd;&#10;}&#10;&#10;.export-settings {&#10;  display: flex;&#10;  flex-direction: column;&#10;  gap: 0.5rem;&#10;  margin-bottom: 1rem;&#10;}&#10;&#10;.export-settings label {&#10;  font-size: 0.85rem;&#10;  font-weight: bold;&#10;  color: #333;&#10;}&#10;&#10;.export-settings input,&#10;.export-settings select {&#10;  padding: 0.5rem;&#10;  border: 1px solid #ddd;&#10;  border-radius: 0.25rem;&#10;  font-size: 0.9rem;&#10;}&#10;&#10;.empty-state {&#10;  text-align: center;&#10;  color: #666;&#10;  font-style: italic;&#10;  padding: 2rem;&#10;}&#10;&#10;/* Sortable styles */&#10;.thumb-item.sortable-ghost {&#10;  opacity: 0.4;&#10;}&#10;&#10;.thumb-item.sortable-chosen {&#10;  background: #e3f2fd;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/utils/utilities.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/utils/utilities.js" />
              <option name="originalContent" value="// Storage utilities for Snap Doc Pro&#10;export class StorageManager {&#10;  static async get(keys) {&#10;    return new Promise((resolve) =&gt; {&#10;      chrome.storage.session.get(keys, resolve);&#10;    });&#10;  }&#10;&#10;  static async set(data) {&#10;    return new Promise((resolve) =&gt; {&#10;      chrome.storage.session.set(data, resolve);&#10;    });&#10;  }&#10;&#10;  static async remove(keys) {&#10;    return new Promise((resolve) =&gt; {&#10;      chrome.storage.session.remove(keys, resolve);&#10;    });&#10;  }&#10;&#10;  static async clear() {&#10;    return new Promise((resolve) =&gt; {&#10;      chrome.storage.session.clear(resolve);&#10;    });&#10;  }&#10;&#10;  // Local storage for settings&#10;  static async getSettings() {&#10;    return new Promise((resolve) =&gt; {&#10;      chrome.storage.local.get(['snapDocSettings'], (result) =&gt; {&#10;        resolve(result.snapDocSettings || this.getDefaultSettings());&#10;      });&#10;    });&#10;  }&#10;&#10;  static async saveSettings(settings) {&#10;    return new Promise((resolve) =&gt; {&#10;      chrome.storage.local.set({ snapDocSettings: settings }, resolve);&#10;    });&#10;  }&#10;&#10;  static getDefaultSettings() {&#10;    return {&#10;      theme: 'light',&#10;      defaultImageSize: 'medium',&#10;      autoSave: true,&#10;      showNotifications: true,&#10;      defaultExportFormat: 'docx',&#10;      includeTimestamps: true,&#10;      includePageInfo: true,&#10;      compressionQuality: 90,&#10;      maxScreenshots: 50&#10;    };&#10;  }&#10;}&#10;&#10;// Export utilities&#10;export class ExportManager {&#10;  constructor() {&#10;    this.formats = {&#10;      docx: this.exportDocx.bind(this),&#10;      pdf: this.exportPdf.bind(this),&#10;      html: this.exportHtml.bind(this),&#10;      zip: this.exportZip.bind(this)&#10;    };&#10;  }&#10;&#10;  async export(snapshots, format, options) {&#10;    if (!this.formats[format]) {&#10;      throw new Error(`Unsupported export format: ${format}`);&#10;    }&#10;&#10;    return await this.formats[format](snapshots, options);&#10;  }&#10;&#10;  async exportDocx(snapshots, options) {&#10;    const { title, imageSize, includeTimestamps, includePageInfo } = options;&#10;&#10;    const imageSizes = {&#10;      small: { width: 300, height: 200 },&#10;      medium: { width: 500, height: 300 },&#10;      large: { width: 700, height: 450 }&#10;    };&#10;    const { width, height } = imageSizes[imageSize] || imageSizes.medium;&#10;&#10;    const children = [&#10;      new docx.Paragraph({&#10;        children: [&#10;          new docx.TextRun({&#10;            text: title,&#10;            bold: true,&#10;            size: 32&#10;          })&#10;        ]&#10;      }),&#10;      new docx.Paragraph({&#10;        children: [&#10;          new docx.TextRun({&#10;            text: `Generated on: ${new Date().toLocaleString()}`,&#10;            italics: true,&#10;            size: 20&#10;          })&#10;        ]&#10;      }),&#10;      new docx.Paragraph({ children: [new docx.TextRun({ text: &quot;&quot; })] })&#10;    ];&#10;&#10;    for (let idx = 0; idx &lt; snapshots.length; idx++) {&#10;      const snapshot = snapshots[idx];&#10;&#10;      try {&#10;        // Convert image&#10;        const response = await fetch(snapshot.dataUrl);&#10;        const blob = await response.blob();&#10;        const arrayBuffer = await blob.arrayBuffer();&#10;        const imageBuffer = new Uint8Array(arrayBuffer);&#10;&#10;        // Add title&#10;        children.push(&#10;          new docx.Paragraph({&#10;            children: [&#10;              new docx.TextRun({&#10;                text: `Screenshot ${idx + 1}`,&#10;                bold: true,&#10;                size: 24&#10;              })&#10;            ]&#10;          })&#10;        );&#10;&#10;        // Add page info if available and enabled&#10;        if (includePageInfo &amp;&amp; snapshot.url) {&#10;          children.push(&#10;            new docx.Paragraph({&#10;              children: [&#10;                new docx.TextRun({&#10;                  text: `URL: ${snapshot.url}`,&#10;                  size: 18,&#10;                  color: &quot;666666&quot;&#10;                })&#10;              ]&#10;            })&#10;          );&#10;        }&#10;&#10;        // Add timestamp if enabled&#10;        if (includeTimestamps &amp;&amp; snapshot.timestamp) {&#10;          children.push(&#10;            new docx.Paragraph({&#10;              children: [&#10;                new docx.TextRun({&#10;                  text: `Captured: ${snapshot.timestamp}`,&#10;                  size: 18,&#10;                  color: &quot;666666&quot;&#10;                })&#10;              ]&#10;            })&#10;          );&#10;        }&#10;&#10;        // Add annotation&#10;        if (snapshot.annotation?.trim()) {&#10;          children.push(&#10;            new docx.Paragraph({&#10;              children: [&#10;                new docx.TextRun({&#10;                  text: `Note: ${snapshot.annotation.trim()}`,&#10;                  italics: true,&#10;                  size: 20&#10;                })&#10;              ]&#10;            })&#10;          );&#10;        }&#10;&#10;        children.push(&#10;          new docx.Paragraph({ children: [new docx.TextRun({ text: &quot;&quot; })] })&#10;        );&#10;&#10;        // Add image&#10;        children.push(&#10;          new docx.Paragraph({&#10;            children: [&#10;              new docx.ImageRun({&#10;                data: imageBuffer,&#10;                transformation: { width, height }&#10;              })&#10;            ]&#10;          })&#10;        );&#10;&#10;        children.push(&#10;          new docx.Paragraph({ children: [new docx.TextRun({ text: &quot;&quot; })] })&#10;        );&#10;&#10;      } catch (error) {&#10;        console.error(`Error processing image ${idx + 1}:`, error);&#10;        children.push(&#10;          new docx.Paragraph({&#10;            children: [&#10;              new docx.TextRun({&#10;                text: `[Error loading Screenshot ${idx + 1}: ${error.message}]`,&#10;                italics: true&#10;              })&#10;            ]&#10;          })&#10;        );&#10;      }&#10;    }&#10;&#10;    const doc = new docx.Document({&#10;      creator: &quot;Snap Doc Pro&quot;,&#10;      title: title,&#10;      description: &quot;Screenshots captured with Snap Doc Pro&quot;,&#10;      sections: [{ children }]&#10;    });&#10;&#10;    return await docx.Packer.toBlob(doc);&#10;  }&#10;&#10;  async exportHtml(snapshots, options) {&#10;    const { title, includeTimestamps, includePageInfo } = options;&#10;&#10;    let html = `&#10;      &lt;!DOCTYPE html&gt;&#10;      &lt;html&gt;&#10;      &lt;head&gt;&#10;        &lt;title&gt;${title}&lt;/title&gt;&#10;        &lt;style&gt;&#10;          body { font-family: system-ui, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }&#10;          .header { text-align: center; margin-bottom: 30px; }&#10;          .screenshot { margin-bottom: 30px; page-break-inside: avoid; }&#10;          .screenshot h3 { color: #333; }&#10;          .screenshot img { max-width: 100%; height: auto; border: 1px solid #ddd; }&#10;          .meta { color: #666; font-size: 0.9em; margin: 10px 0; }&#10;          .annotation { background: #f5f5f5; padding: 10px; border-left: 4px solid #007cba; margin: 10px 0; }&#10;          @media print { .screenshot { page-break-after: always; } }&#10;        &lt;/style&gt;&#10;      &lt;/head&gt;&#10;      &lt;body&gt;&#10;        &lt;div class=&quot;header&quot;&gt;&#10;          &lt;h1&gt;${title}&lt;/h1&gt;&#10;          &lt;p&gt;Generated on: ${new Date().toLocaleString()}&lt;/p&gt;&#10;        &lt;/div&gt;&#10;    `;&#10;&#10;    snapshots.forEach((snapshot, idx) =&gt; {&#10;      html += `&lt;div class=&quot;screenshot&quot;&gt;`;&#10;      html += `&lt;h3&gt;Screenshot ${idx + 1}&lt;/h3&gt;`;&#10;&#10;      if (includePageInfo &amp;&amp; snapshot.url) {&#10;        html += `&lt;div class=&quot;meta&quot;&gt;URL: &lt;a href=&quot;${snapshot.url}&quot;&gt;${snapshot.url}&lt;/a&gt;&lt;/div&gt;`;&#10;      }&#10;&#10;      if (includeTimestamps &amp;&amp; snapshot.timestamp) {&#10;        html += `&lt;div class=&quot;meta&quot;&gt;Captured: ${snapshot.timestamp}&lt;/div&gt;`;&#10;      }&#10;&#10;      if (snapshot.annotation?.trim()) {&#10;        html += `&lt;div class=&quot;annotation&quot;&gt;${snapshot.annotation}&lt;/div&gt;`;&#10;      }&#10;&#10;      html += `&lt;img src=&quot;${snapshot.dataUrl}&quot; alt=&quot;Screenshot ${idx + 1}&quot;&gt;`;&#10;      html += `&lt;/div&gt;`;&#10;    });&#10;&#10;    html += `&lt;/body&gt;&lt;/html&gt;`;&#10;&#10;    return new Blob([html], { type: 'text/html' });&#10;  }&#10;&#10;  async exportZip(snapshots, options) {&#10;    // This would require a ZIP library like JSZip&#10;    // For now, return a placeholder&#10;    const content = JSON.stringify({ snapshots, options, exported: new Date().toISOString() }, null, 2);&#10;    return new Blob([content], { type: 'application/json' });&#10;  }&#10;&#10;  async exportPdf(snapshots, options) {&#10;    // This would require a PDF library like jsPDF&#10;    // For now, return HTML that can be printed to PDF&#10;    return this.exportHtml(snapshots, options);&#10;  }&#10;}&#10;&#10;// Notification utilities&#10;export class NotificationManager {&#10;  static show(title, message, type = 'success') {&#10;    // Create in-app notification&#10;    const notification = document.createElement('div');&#10;    notification.className = `snap-notification snap-${type}`;&#10;    notification.innerHTML = `&#10;      &lt;div class=&quot;snap-notification-content&quot;&gt;&#10;        &lt;strong&gt;${title}&lt;/strong&gt;&#10;        &lt;p&gt;${message}&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    `;&#10;&#10;    document.body.appendChild(notification);&#10;&#10;    setTimeout(() =&gt; {&#10;      notification.classList.add('show');&#10;    }, 10);&#10;&#10;    setTimeout(() =&gt; {&#10;      notification.classList.remove('show');&#10;      setTimeout(() =&gt; notification.remove(), 300);&#10;    }, 3000);&#10;  }&#10;&#10;  static error(title, message) {&#10;    this.show(title, message, 'error');&#10;  }&#10;&#10;  static success(title, message) {&#10;    this.show(title, message, 'success');&#10;  }&#10;&#10;  static info(title, message) {&#10;    this.show(title, message, 'info');&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="// No utility functions were present in the original Snap Doc extension" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>